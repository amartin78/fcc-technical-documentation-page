<!DOCTYPE html>
<html>
    <head>
        <link rel="stylesheet" type="text/css" href="style.css">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.1/css/all.css"
            integrity="sha384-50oBUHEmvpQ+1lW4y57PTFmhCaXp0ML5d60M1M7uH2+nqUivzIebhndOJK28anvf" crossorigin="anonymous">
    </head>
    <body>  
        <nav id="navbar">
            <header>
                <h2>Python<br>Functional Programming<br>HOWTO</h2>
            </header>
            <ul>
                <li><a class="nav-link" href="#Introduction">Introduction</a></li>
                <li><a class="nav-link" href="#Iterators">Iterators</a></li>
                <li> <a class="nav-link" href="#Generator_expressions_and_list_comprehensions">Generator expressions and list comprehensions</a></li>
                <li><a class="nav-link" href="#Generators">Generators</a></li>
                <li><a class="nav-link" href="#Built-in_functions">Built-in functions</a></li>
                <li><a class="nav-link" href="#The_itertools_module">The itertools module</a></li>
                <li><a class="nav-link" href="#The_functools_module">The functools module</a></li>
                <li><a class="nav-link" href="#Small_functions_and_the_lambda_expression">Small functions and the lambda expression</a></li>
                <li><a class="nav-link" href="#Revision_History_and_Acknowledgements">Revision History and Acknowledgements</a></li>
                <li><a class="nav-link" href="#References">References</a></li>
            </ul>
        </nav>
        <main id="main-doc">
            <section class="main-section" id="Introduction">
                <header>
                    <p>Introduction</p>
                </header>
                <p>This section explains the basic concept of functional programming; if you’re just interested in
                    learning
                    about Python language features, skip to the next section on Iterators.</p>
                <p>Programming languages support decomposing problems in several different ways:</p>
                <ul>
                    <li>Most programming languages are procedural: programs are lists of instructions that tell the
                        computer
                        what to do
                        with the program’s input. C, Pascal, and even Unix shells are procedural languages.</li>
                    <li>In declarative languages, you write a specification that describes the problem to be solved, and
                        the
                        language
                        implementation figures out how to perform the computation efficiently. SQL is the declarative
                        language you’re
                        most likely to be familiar with; a SQL query describes the data set you want to retrieve, and
                        the
                        SQL engine
                        decides whether to scan tables or use indexes, which subclauses should be performed first, etc.
                    </li>
                    <li>Object-oriented programs manipulate collections of objects. Objects have internal state and
                        support
                        methods
                        that query or modify this internal state in some way. Smalltalk and Java are object-oriented
                        languages. C++ and
                        Python are languages that support object-oriented programming, but don’t force the use of
                        object-oriented
                        features.</li>
                    <li>Functional programming decomposes a problem into a set of functions. Ideally, functions only
                        take
                        inputs and
                        produce outputs, and don’t have any internal state that affects the output produced for a given
                        input.
                        Well-known functional languages include the ML family (Standard ML, OCaml, and other variants)
                        and
                        Haskell.</li>
                </ul>
                <p>The designers of some computer languages choose to emphasize one particular approach to programming.
                    This
                    often makes it difficult to
                    write programs that use a different approach. Other languages are multi-paradigm languages that
                    support
                    several different approaches.
                    Lisp, C++, and Python are multi-paradigm; you can write programs or libraries that are largely
                    procedural, object-oriented, or
                    functional in all of these languages. In a large program, different sections might be written using
                    different approaches; the GUI
                    might be object-oriented while the processing logic is procedural or functional, for example.</p>
                <p>In a functional program, input flows through a set of functions. Each function operates on its input
                    and
                    produces some
                    output. Functional style discourages functions with side effects that modify internal state or make
                    other changes that
                    aren’t visible in the function’s return value. Functions that have no side effects at all are called
                    purely functional.
                    Avoiding side effects means not using data structures that get updated as a program runs; every
                    function’s output must
                    only depend on its input.</p>
                <p>Some languages are very strict about purity and don’t even have assignment statements such as a=3 or
                    c =
                    a + b, but it’s difficult to avoid all side effects. Printing to the screen or writing to a disk
                    file
                    are side effects, for example. For example, in Python a call to the print() or time.sleep() function
                    both return no useful value; they’re only called for their side effects of sending some text to the
                    screen or pausing execution for a second.</p>
                <p>Python programs written in functional style usually won’t go to the extreme of avoiding all I/O or
                    all
                    assignments; instead, they’ll provide a functional-appearing interface but will use non-functional
                    features internally. For example, the implementation of a function will still use assignments to
                    local
                    variables, but won’t modify global variables or have other side effects.</p>
                <p>Functional programming can be considered the opposite of object-oriented programming. Objects are
                    little
                    capsules containing some internal state along with a collection of method calls that let you modify
                    this
                    state, and programs consist of making the right set of state changes. Functional programming wants
                    to
                    avoid state changes as much as possible and works with data flowing between functions. In Python you
                    might combine the two approaches by writing functions that take and return instances representing
                    objects in your application (e-mail messages, transactions, etc.).</p>
                <p>Functional design may seem like an odd constraint to work under. Why should you avoid objects and
                    side
                    effects? There are theoretical and practical advantages to the functional style:</p>
                <ul>
                    <li>Formal provability</li>
                    <li>Modularity</li>
                    <li>Composability</li>
                    <li>Ease of debugging and testing</li>
                </ul>

            </section>

            <section class="main-section" id="Iterators">
                <header>
                    <p>Iterators</p>
                </header>
                <p>I’ll start by looking at a Python language feature that’s an important foundation for writing
                    functional-style programs: iterators.</p>
                <p>An iterator is an object representing a stream of data; this object returns the data one element at a
                    time. A Python iterator must support a method called __next__() that takes no arguments and always
                    returns the next element of the stream. If there are no more elements in the stream, __next__() must
                    raise the StopIteration exception. Iterators don’t have to be finite, though; it’s perfectly
                    reasonable
                    to write an iterator that produces an infinite stream of data.</p>
                <p>The built-in iter() function takes an arbitrary object and tries to return an iterator that will
                    return
                    the object’s contents or elements, raising TypeError if the object doesn’t support iteration.
                    Several of
                    Python’s built-in data types support iteration, the most common being lists and dictionaries. An
                    object
                    is called iterable if you can get an iterator for it.</p>
                <p>You can experiment with the iteration interface manually:</p>
                <div class="code-frame"><code>
                        >>> L = [1, 2, 3]<br>
                        >>> it = iter(L)<br>
                        >>> it  #doctest: +ELLIPSIS<br>
                        <...iterator object at ...><br>
                        >>> it.__next__()  # same as next(it)<br>
                        1<br>
                        >>> next(it)<br>
                        2<br>
                        >>> next(it)<br>
                        3<br>
                        >>> next(it)<br>
                        Traceback (most recent call last):<br>
                        File "<stdin>", line 1, in <module><br>
                        StopIteration<br>
                        >>>
                </code></div>
                <p>Python expects iterable objects in several different contexts, the most important being the for
                    statement. In the statement for X in Y, Y must be an iterator or some object for which iter() can
                    create
                    an iterator. These two statements are equivalent:</p>
                <div class="code-frame"><code>
                    for i in iter(obj):<br>
                    &nbsp;print(i)<br><br>
                    for i in obj:<br>
                    &nbsp;print(i)
                </code></div>
                <p>Iterators can be materialized as lists or tuples by using the list() or tuple() constructor
                    functions:
                </p>
                <div class="code-frame"><code>
                        >>> L = [1, 2, 3]<br>
                        >>> iterator = iter(L)<br>
                        >>> t = tuple(iterator)<br>
                        >>> t<br>
                        (1, 2, 3)
                </code></div>
                <p>Sequence unpacking also supports iterators: if you know an iterator will return N elements, you can
                    unpack them into an N-tuple:</p>
                <div class="code-frame"><code>
                        >>> L = [1, 2, 3]<br>
                        >>> iterator = iter(L)<br>
                        >>> a, b, c = iterator<br>
                        >>> a, b, c<br>
                        (1, 2, 3)
                </code></div>

                <p>Built-in functions such as max() and min() can take a single iterator argument and will return the
                    largest or smallest element. The "in" and "not in" operators also support iterators: X in iterator
                    is
                    true if X is found in the stream returned by the iterator. You’ll run into obvious problems if the
                    iterator is infinite; max(), min() will never return, and if the element X never appears in the
                    stream,
                    the "in" and "not in" operators won’t return either.
                </p>
                <p>Note that you can only go forward in an iterator; there’s no way to get the previous element, reset
                    the
                    iterator, or make a copy of it. Iterator objects can optionally provide these additional
                    capabilities,
                    but the iterator protocol only specifies the __next__() method. Functions may therefore consume all
                    of
                    the iterator’s output, and if you need to do something different with the same stream, you’ll have
                    to
                    create a new iterator.
                </p>
            </section>

            <section class="main-section" id="Generator_expressions_and_list_comprehensions">
                <header>
                    <p>Generator expressions and list comprehensions</p>
                </header>
                <p> Two common operations on an iterator’s output are 1) performing some operation for every element, 2)
                    selecting a subset of elements that meet some condition. For example, given a list of strings, you
                    might
                    want to strip off trailing whitespace from each line or extract all the strings containing a given
                    substring.
                </p>
                <p>List comprehensions and generator expressions (short form: “listcomps” and “genexps”) are a concise
                    notation for such operations, borrowed from the functional programming language Haskell
                    (https://www.haskell.org/). You can strip all the whitespace from a stream of strings with the
                    following
                    code:
                </p>
                <div class="code-frame"><code>
                        line_list = ['  line 1\n', 'line 2  \n', ...]<br><br>
                        <i># Generator expression -- returns iterator</i><br>
                        stripped_iter = (line.strip() for line in line_list)<br><br>
                        <i># List comprehension -- returns list</i><br>
                        stripped_list = [line.strip() for line in line_list]
                </code></div>
                <p>You can select only certain elements by adding an "if" condition:</p>
                <div class="code-frame"><code>
                        stripped_list = [line.strip() for line in line_list
                        if line != ""]
                </code></div>
                <p> With a list comprehension, you get back a Python list; stripped_list is a list containing the
                    resulting
                    lines, not an iterator. Generator expressions return an iterator that computes the values as
                    necessary,
                    not needing to materialize all the values at once. This means that list comprehensions aren’t useful
                    if
                    you’re working with iterators that return an infinite stream or a very large amount of data.
                    Generator
                    expressions are preferable in these situations.
                </p>
                <p>Generator expressions are surrounded by parentheses (“()”) and list comprehensions are surrounded by
                    square brackets (“[]”). Generator expressions have the form:
                </p>
                <div class="code-frame"><code>
                        ( expression for expr in sequence1<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if condition1<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for expr2 in sequence2<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if condition2<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for expr3 in sequence3 ...<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if condition3<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for exprN in sequenceN<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if conditionN )
                </code></div>
                <p> Again, for a list comprehension only the outside brackets are different (square brackets instead of
                    parentheses).
                </p>
                <p>The elements of the generated output will be the successive values of expression. The if clauses are
                    all
                    optional; if present, expression is only evaluated and added to the result when condition is true.
                </p>
                <p>Generator expressions always have to be written inside parentheses, but the parentheses signalling a
                    function call also count. If you want to create an iterator that will be immediately passed to a
                    function you can write:
                </p>
                <div class="code-frame"><code>
                        obj_total = sum(obj.count for obj in list_all_objects())
                </code></div>
                <p> The for...in clauses contain the sequences to be iterated over. The sequences do not have to be the
                    same
                    length, because they are iterated over from left to right, not in parallel. For each element in
                    sequence1, sequence2 is looped over from the beginning. sequence3 is then looped over for each
                    resulting
                    pair of elements from sequence1 and sequence2.
                </p>
                <p> To put it another way, a list comprehension or generator expression is equivalent to the following
                    Python code:
                </p>
                <div class="code-frame"><code>
                    for expr1 in sequence1:<br>
                    &nbsp;&nbsp;if not (condition1):<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;continue   <i># Skip this element</i><br>
                    &nbsp;&nbsp;for expr2 in sequence2:<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;if not (condition2):<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue   <i># Skip this element</i><br>
                    &nbsp;&nbsp;&nbsp;&nbsp;...<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;for exprN in sequenceN:<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if not (conditionN):<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue   <i># Skip this element</i><br><br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Output the value of<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# the expression.<br>
                </code></div>
                <p>This means that when there are multiple for...in clauses but no if clauses, the length of the
                    resulting
                    output will be equal to the product of the lengths of all the sequences. If you have two lists of
                    length
                    3, the output list is 9 elements long:</p>
                <div class="code-frame"><code>
                        >>> seq1 = 'abc'<br>
                        >>> seq2 = (1, 2, 3)<br>
                        >>> [(x, y) for x in seq1 for y in seq2]  #doctest: +NORMALIZE_WHITESPACE<br>
                        [('a', 1), ('a', 2), ('a', 3),<br>
                        ('b', 1), ('b', 2), ('b', 3),<br>
                        ('c', 1), ('c', 2), ('c', 3)]
                </code></div>
                <p>To avoid introducing an ambiguity into Python’s grammar, if expression is creating a tuple, it must
                    be
                    surrounded with parentheses. The first list comprehension below is a syntax error, while the second
                    one
                    is correct:</p>
                <div class="code-frame"><code>
                        <i># Syntax error</i><br>
                        [x, y for x in seq1 for y in seq2]<br>
                        <i># Correct</i><br>
                        [(x, y) for x in seq1 for y in seq2]<br>
                </code></div>
            </section>

            <section class="main-section" id="Generators">
                <header>
                    <p>Generators</p>
                </header>
                <p> Generators are a special class of functions that simplify the task of writing iterators. Regular
                    functions compute a value and return it, but generators return an iterator that returns a stream of
                    values.
                </p>
                <p>You’re doubtless familiar with how regular function calls work in Python or C. When you call a
                    function, it gets a private namespace where its local variables are created. When the function
                    reaches a return statement, the local variables are destroyed and the value is returned to the
                    caller. A later call to the same function creates a new private namespace and a fresh set of local
                    variables. But, what if the local variables weren’t thrown away on exiting a function? What if you
                    could later resume the function where it left off? This is what generators provide; they can be
                    thought of as resumable functions.
                </p>
                <p>Here’s the simplest example of a generator function:
                </p>
                <div class="code-frame"><code>
                        >>> def generate_ints(N):<br>
                        ... &nbsp;&nbsp;for i in range(N):<br>
                        ... &nbsp;&nbsp;&nbsp;&nbsp;yield i
                </code></div>
                <p> Any function containing a yield keyword is a generator function; this is detected by Python’s
                    bytecode compiler which compiles the function specially as a result.
                </p>
                <p>When you call a generator function, it doesn’t return a single value; instead it returns a generator
                    object that supports the iterator protocol. On executing the yield expression, the generator outputs
                    the value of i, similar to a return statement. The big difference between yield and a return
                    statement is that on reaching a yield the generator’s state of execution is suspended and local
                    variables are preserved. On the next call to the generator’s __next__() method, the function will
                    resume executing.
                </p>
                <p>Here’s a sample usage of the generate_ints() generator:
                </p>
                <div class="code-frame"><code>
                        >>> gen = generate_ints(3)<br>
                        >>> gen  #doctest: +ELLIPSIS<br>
                        &lt;generator object generate_ints at ...&gt;<br>
                        >>> next(gen)<br>
                        0<br>
                        >>> next(gen)<br>
                        1<br>
                        >>> next(gen)<br>
                        2<br>
                        >>> next(gen)<br>
                        Traceback (most recent call last):<br>
                        &nbsp;&nbsp;File "stdin", line 1, in <module><br>
                        &nbsp;&nbsp;File "stdin", line 2, in generate_ints<br>
                        StopIteration
                </code></div>
                <p> You could equally write for i in generate_ints(5), or a, b, c = generate_ints(3).
                </p>
                <p>Inside a generator function, return value causes StopIteration(value) to be raised from the
                    __next__() method. Once this happens, or the bottom of the function is reached, the procession of
                    values ends and the generator cannot yield any further values.
                </p>
                <p>You could achieve the effect of generators manually by writing your own class and storing all the
                    local variables of the generator as instance variables. For example, returning a list of integers
                    could be done by setting self.count to 0, and having the __next__() method increment self.count and
                    return it. However, for a moderately complicated generator, writing a corresponding class can be
                    much messier.
                </p>
                <p>The test suite included with Python’s library, Lib/test/test_generators.py, contains a number of more
                    interesting examples. Here’s one generator that implements an in-order traversal of a tree using
                    generators recursively.
                </p>
                <div class="code-frame"><code>
                        <i># A recursive generator that generates Tree leaves in in-order.</i><br>
                        def inorder(t):<br>
                        &nbsp;&nbsp;if t:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;for x in inorder(t.left):<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield x<br><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;yield t.label<br><br>
                        &nbsp;&nbsp;&nbsp;&nbsp;for x in inorder(t.right):<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield x<br>
                </code></div>
                <p>Two other examples in test_generators.py produce solutions for the N-Queens problem (placing N queens
                    on an NxN chess board so that no queen threatens another) and the Knight’s Tour (finding a route
                    that takes a knight to every square of an NxN chessboard without visiting any square twice).</p>
            </section>

            <section class="main-section" id="Built-in_functions">
                <header>
                    <p>Built-in functions</p>
                </header>
                <p>Let’s look in more detail at built-in functions often used with iterators.
                    Two of Python’s built-in functions, map() and filter() duplicate the features of generator
                    expressions:</p>
                <p>map(f, iterA, iterB, ...) returns an iterator over the sequence
                    f(iterA[0], iterB[0]), f(iterA[1], iterB[1]), f(iterA[2], iterB[2]), ....</p>
                <div class="code-frame"><code>
                    >>> def upper(s):<br>
                    ... &nbsp;&nbsp;return s.upper()
                </code></div>
                <div class="code-frame"><code>
                        >>> list(map(upper, ['sentence', 'fragment']))<br>
                        ['SENTENCE', 'FRAGMENT']<br>
                        >>> [upper(s) for s in ['sentence', 'fragment']]<br>
                        ['SENTENCE', 'FRAGMENT']
                </code></div>
                <p> You can of course achieve the same effect with a list comprehension.
                </p>
                <p>
                    <code>filter(predicate, iter) </code>returns an iterator over all the
                    sequence elements that meet a
                    certain condition, and is similarly duplicated by list comprehensions. A predicate is a function
                    that returns the truth value of some condition; for use with filter(), the predicate must take a
                    single value.
                </p>
                <div class="code-frame"><code>
                        >>> def is_even(x):<br>
                        ... &nbsp;&nbsp;return (x % 2) == 0
                </code></div>
                <div class="code-frame"><code>
                        >>> list(filter(is_even, range(10)))<br>
                        [0, 2, 4, 6, 8]
                </code></div>
                <p>This can also be written as a list comprehension:</p>
                <div class="code-frame"><code>
                        >>> list(x for x in range(10) if is_even(x))<br>
                        [0, 2, 4, 6, 8]
                </code></div>
                <p><code>enumerate(iter, start=0)</code> counts off the elements in the iterable returning 2-tuples
                    containing the count (from start) and each element.</p>
                <div class="code-frame"><code>
                        >>> for item in enumerate(['subject', 'verb', 'object']):<br>
                        ...     print(item)<br>
                        (0, 'subject')<br>
                        (1, 'verb')<br>
                        (2, 'object')
                </code></div>
                <p><code>enumerate()</code> is often used when looping through a list and recording the indexes at which
                    certain conditions are met:</p>
                <div class="code-frame"><code>
                        f = open('data.txt', 'r')<br>
                        for i, line in enumerate(f):<br>
                        &nbsp;&nbsp;if line.strip() == '':<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;print('Blank line at line #%i' % i)
                </code></div>
                <p><code>sorted(iterable, key=None, reverse=False)</code> collects all the elements of the iterable into
                    a list,
                    sorts the list, and returns the sorted result. The key and reverse arguments are passed through to
                    the constructed list’s sort() method.</p>
                <div class="code-frame"><code>
                        >>> import random<br>
                        >>> # Generate 8 random numbers between [0, 10000)<br>
                        >>> rand_list = random.sample(range(10000), 8)<br>
                        >>> rand_list<br>
                        [769, 7953, 9828, 6431, 8442, 9878, 6213, 2207]<br>
                        >>> sorted(rand_list)<br>
                        [769, 2207, 6213, 6431, 7953, 8442, 9828, 9878]<br>
                        >>> sorted(rand_list, reverse=True)<br>  
                        [9878, 9828, 8442, 7953, 6431, 6213, 2207, 769]
                </code></div>
                <p>(For a more detailed discussion of sorting, see the Sorting HOW TO.)</p>
                <p>The <code>any(iter)</code> and <code>all(iter)</code> built-ins look at the truth values of an
                    iterable’s contents. any()
                    returns True if any element in the iterable is a true value, and all() returns True if all of the
                    elements are true values:</p>
                <div class="code-frame"><code>
                        >>> any([0, 1, 0])<br>
                        True<br>
                        >>> any([0, 0, 0])<br>
                        False<br>
                        >>> any([1, 1, 1])<br>
                        True<br>
                        >>> all([0, 1, 0])<br>
                        False<br>
                        >>> all([0, 0, 0])<br>
                        False<br>
                        >>> all([1, 1, 1])<br>
                        True
                </code></div>
                <p><code>zip(iterA, iterB, ...)</code> takes one element from each iterable and returns them in a tuple:
                </p>
                <div class="code-frame"><code>
                        zip(['a', 'b', 'c'], (1, 2, 3)) =><br>
                        &nbsp;&nbsp;('a', 1), ('b', 2), ('c', 3)
                </code></div>

                <p> It doesn’t construct an in-memory list and exhaust all the input iterators before returning; instead
                    tuples are constructed and returned only if they’re requested. (The technical term for this
                    behaviour is lazy evaluation.)
                </p>
                <p>This iterator is intended to be used with iterables that are all of the same length. If the iterables
                    are of different lengths, the resulting stream will be the same length as the shortest iterable.
                </p>
                <div class="code-frame"><code>
                        zip(['a', 'b'], (1, 2, 3)) =><br>
                        &nbsp;&nbsp;('a', 1), ('b', 2)
                </code></div>
                <p>You should avoid doing this, though, because an element may be taken from the longer iterators and
                    discarded. This means you can’t go on to use the iterators further because you risk skipping a
                    discarded element.</p>
            </section>

            <section class="main-section" id="The_itertools_module">
                <header>
                    <p>The itertools module</p>
                </header>
                <p>The itertools module contains a number of commonly-used iterators as well as functions for combining
                    several iterators. This section will introduce the module’s contents by showing small examples.</p>
                <p>The module’s functions fall into a few broad classes:</p>
                <ul>
                    <li> Functions that create a new iterator based on an existing iterator.
                    </li>
                    <li> Functions for treating an iterator’s elements as function arguments.
                    </li>
                    <li> Functions for selecting portions of an iterator’s output.
                    </li>
                    <li> A function for grouping an iterator’s output.</p>
                    </li>
                </ul>
            </section>

            <section class="main-section" id="The_functools_module">
                <header>
                    <p>The functools module</p>
                </header>
                <p> The functools module in Python 2.5 contains some higher-order functions. A higher-order function
                    takes one or more functions as input and returns a new function. The most useful tool in this module
                    is the functools.partial() function.
                </p>
                <p>For programs written in a functional style, you’ll sometimes want to construct variants of existing
                    functions that have some of the parameters filled in. Consider a Python function f(a, b, c); you may
                    wish to create a new function g(b, c) that’s equivalent to f(1, b, c); you’re filling in a value for
                    one of f()’s parameters. This is called “partial function application”.
                </p>
                <p>The constructor for partial() takes the arguments (function, arg1, arg2, ..., kwarg1=value1,
                    kwarg2=value2). The resulting object is callable, so you can just call it to invoke function with
                    the filled-in arguments.
                </p>
                <p>Here’s a small but realistic example:
                </p>
                <div class="code-frame"><code>
                        import functools<br><br>
                        def log(message, subsystem):<br>
                        &nbsp;&nbsp;"""Write the contents of 'message' to the specified subsystem."""<br>
                        &nbsp;&nbsp;print('%s: %s' % (subsystem, message))<br>
                        &nbsp;&nbsp;...<br><br>
                        server_log = functools.partial(log, subsystem='server')<br>
                        server_log('Unable to open socket')
                </code></div>
                <p><code>functools.reduce(func, iter, [initial_value])</code> cumulatively performs an operation on all
                    the iterable’s elements and, therefore, can’t be applied to infinite iterables. func must be a
                    function that takes two elements and returns a single value. functools.reduce() takes the first two
                    elements A and B returned by the iterator and calculates func(A, B). It then requests the third
                    element, C, calculates func(func(A, B), C), combines this result with the fourth element returned,
                    and continues until the iterable is exhausted. If the iterable returns no values at all, a TypeError
                    exception is raised. If the initial value is supplied, it’s used as a starting point and
                    func(initial_value, A) is the first calculation.</p>
                <div class="code-frame"><code>
                        >>> import operator, functools<br>
                        >>> functools.reduce(operator.concat, ['A', 'BB', 'C'])<br>
                        'ABBC'<br>
                        >>> functools.reduce(operator.concat, [])<br>
                        Traceback (most recent call last):<br>
                        ...<br>
                        TypeError: reduce() of empty sequence with no initial value<br>
                        >>> functools.reduce(operator.mul, [1, 2, 3], 1)<br>
                        6<br>
                        >>> functools.reduce(operator.mul, [], 1)<br>
                        1
                </code></div>
                <p>If you use operator.add() with functools.reduce(), you’ll add up all the elements of the iterable.
                    This case is so common that there’s a special built-in called sum() to compute it:</p>
                <div class="code-frame"><code>
                        >>> import functools, operator<br>
                        >>> functools.reduce(operator.add, [1, 2, 3, 4], 0)<br>
                        10<br>
                        >>> sum([1, 2, 3, 4])<br>
                        10<br>
                        >>> sum([])<br>
                        0
                </code></div>
                <p>For many uses of <code>functools.reduce()</code>, though, it can be clearer to just write the obvious
                    for loop:</p>
                <div class="code-frame"><code>
                        import functools<br>
                        # Instead of:<br>
                        product = functools.reduce(operator.mul, [1, 2, 3], 1)<br><br>
                        # You can write:<br>
                        product = 1<br>
                        for i in [1, 2, 3]:<br>
                        &nbsp;&nbsp;product *= i
                </code></div>
                <p>A related function is itertools.accumulate(iterable, func=operator.add). It performs the same
                    calculation, but instead of returning only the final result, accumulate() returns an iterator that
                    also yields each partial result:</p>
                <div class="code-frame"><code>
                        itertools.accumulate([1, 2, 3, 4, 5]) =><br>
                        1, 3, 6, 10, 15<br><br>
                        itertools.accumulate([1, 2, 3, 4, 5], operator.mul) =><br>
                        1, 2, 6, 24, 120
                </code></div>
            </section>

            <section class="main-section" id="Small_functions_and_the_lambda_expression">
                <header>
                    <p>Small functions and the lambda expression</p>
                </header>
                <p> When writing functional-style programs, you’ll often need little functions that act as predicates or
                    that combine elements in some way.
                </p>
                <p>If there’s a Python built-in or a module function that’s suitable, you don’t need to define a new
                    function at all:
                </p>
                <div class="code-frame"><code>
                        stripped_lines = [line.strip() for line in lines]<br>
                        existing_files = filter(os.path.exists, file_list)
                </code></div>
                <p>If the function you need doesn’t exist, you need to write it. One way to write small functions is to
                    use the lambda expression. lambda takes a number of parameters and an expression combining these
                    parameters, and creates an anonymous function that returns the value of the expression:</p>
                <div class="code-frame"><code>
                        adder = lambda x, y: x+y<br><br>
                        print_assign = lambda name, value: name + '=' + str(value)
                </code></div>
                <p>An alternative is to just use the def statement and define a function in the usual way:</p>
                <div class="code-frame"><code>
                        def adder(x, y):<br>
                        &nbsp;&nbsp;return x + y<br><br>
                        def print_assign(name, value):<br>
                        &nbsp;&nbsp;return name + '=' + str(value)
                </code></div>
                <p>Which alternative is preferable? That’s a style question; my usual course is to avoid using lambda.
                </p>
                <p>One reason for my preference is that lambda is quite limited in the functions it can define. The
                    result has to be computable as a single expression, which means you can’t have multiway if...
                    elif... else comparisons or try... except statements. If you try to do too much in a lambda
                    statement, you’ll end up with an overly complicated expression that’s hard to read. Quick, what’s
                    the following code doing?</p>
                <div class="code-frame"><code>
                        import functools<br>
                        total = functools.reduce(lambda a, b: (0, a[1] + b[1]), items)[1]
                </code></div>
                <p>You can figure it out, but it takes time to disentangle the expression to figure out what’s going on.
                    Using a short nested def statements makes things a little bit better:</p>
                <div class="code-frame"><code>
                        import functools<br>
                        def combine(a, b):<br>
                        &nbsp;&nbsp;return 0, a[1] + b[1]<br><br>
                        total = functools.reduce(combine, items)[1]
                </code></div>
                <p>But it would be best of all if I had simply used a for loop:</p>
                <div class="code-frame"><code>
                        total = 0<br>
                        for a, b in items:<br>
                        &nbsp;&nbsp;total += b
                </code></div>
                <p>Or the sum() built-in and a generator expression:</p>
                <div class="code-frame"><code>
                        total = sum(b for a, b in items)
                </code></div>
                <p> Many uses of functools.reduce() are clearer when written as for loops.
                </p>
                <p>Fredrik Lundh once suggested the following set of rules for refactoring uses of lambda:
                </p>
                <ol>
                    <li>Write a lambda function.</li>
                    <li>Write a comment explaining what the heck that lambda does.</li>
                    <li>Study the comment for a while, and think of a name that captures the essence of the comment.
                    </li>
                    <li>Convert the lambda to a def statement, using that name.</li>
                    <li>Remove the comment.</li>
                </ol>
                <p>I really like these rules, but you’re free to disagree about whether this lambda-free style is
                    better.

                </p>
            </section>

            <section class="main-section" id="Revision_History_and_Acknowledgements">
                <header>
                    <p>Revision History and Acknowledgements</p>
                </header>
                <p>The author would like to thank the following people for offering suggestions, corrections and
                    assistance with various drafts of this article: Ian Bicking, Nick Coghlan, Nick Efford, Raymond
                    Hettinger, Jim Jewett, Mike Krell, Leandro Lameiro, Jussi Salmela, Collin Winter, Blake Winton.
                </p>
                <p>Version 0.1: posted June 30 2006.
                </p>
                <p>Version 0.11: posted July 1 2006. Typo fixes.
                </p>
                <p>Version 0.2: posted July 10 2006. Merged genexp and listcomp sections into one. Typo fixes.
                </p>
                <p>Version 0.21: Added more references suggested on the tutor mailing list.
                </p>
                <p>Version 0.30: Adds a section on the functional module written by Collin Winter; adds short section on
                    the operator module; a few other edits.
                </p>
            </section>

            <section class="main-section" id="References">
                <header>
                    <p>References</p>
                </header>

                <h3>General</h3>

                <p>Structure and Interpretation of Computer Programs, by Harold Abelson and Gerald Jay Sussman with
                    Julie Sussman. Full text at <a href="https://mitpress.mit.edu/sites/default/files/sicp/index.html"
                        target="_blank">https://mitpress.mit.edu/sicp/</a>. In this classic textbook of computer
                    science, chapters 2 and 3 discuss the use of sequences and streams to organize the data flow inside
                    a program. The book uses Scheme for its examples, but many of the design approaches described in
                    these chapters are applicable to functional-style Python code.
                </p>
                <p><a href="http://www.defmacro.org/ramblings/fp.html"
                        target="_blank">http://www.defmacro.org/ramblings/fp.html</a>: A general introduction to
                    functional programming that uses
                    Java examples and has a lengthy historical introduction.
                </p>
                <p><a href="https://en.wikipedia.org/wiki/Functional_programming"
                        target="_blank">https://en.wikipedia.org/wiki/Functional_programming</a>: General Wikipedia
                    entry describing functional
                    programming.
                </p>
                <p><a href="https://en.wikipedia.org/wiki/Coroutine"
                        target="_blank">https://en.wikipedia.org/wiki/Coroutine</a>: Entry for coroutines.
                </p>
                <p><a href="https://en.wikipedia.org/wiki/Currying"
                        target="_blank">https://en.wikipedia.org/wiki/Currying</a>: Entry for the concept of currying.
                </p>

                <h3>Python-specific</h3>

                <p><a href="http://gnosis.cx/TPiP/" target="_blank">http://gnosis.cx/TPiP/</a>: The first chapter of
                    David Mertz’s book Text Processing in Python discusses
                    functional programming for text processing, in the section titled “Utilizing Higher-Order Functions
                    in
                    Text Processing”.</p>
                <p>Mertz also wrote a 3-part series of articles on functional programming for IBM’s DeveloperWorks site;
                    see <a href="https://developer.ibm.com/technologies/linux/" target="_blank">part 1</a>, <a
                        href="https://developer.ibm.com/tutorials/l-prog2/" target="_blank">part 2</a>, and <a
                        href="https://developer.ibm.com/tutorials/l-prog3/" target="_blank">part 3</a>,</p>

                <h3> Python documentation</h3>

                <p> Documentation for the <a href="https://docs.python.org/3.7/library/itertools.html#module-itertools"
                        target="_blank"><code>itertools</code></a> module.
                </p>
                <p> Documentation for the <a href="https://docs.python.org/3.7/library/functools.html#module-functools"
                        target="_blank"><code>functools</code></a> module.
                </p>
                <p> Documentation for the <a href="https://docs.python.org/3.7/library/operator.html#module-operator"
                        target="_blank"><code>operator</code></a> module.
                </p>
                <p><a href="https://www.python.org/dev/peps/pep-0289/" target="_blank">PEP 289</a>: “Generator
                    Expressions”
                </p>
                <p><a href="https://www.python.org/dev/peps/pep-0342/" target="_blank">PEP 342</a>: “Coroutines via
                    Enhanced Generators” describes the new generator features in Python 2.5.
                </p>
                <p>-- All the documentation in this page is taken from <a
                        href="https://docs.python.org/3.7/howto/functional.html" target="_blank">Python Software
                        Foundation</a> --</p>
            </section>
        </main>
        <div id="start">
            <a href="#navbar">
                <i class="fa fa-angle-up"></i>
            </a>
        </div>
        <script src="https://cdn.freecodecamp.org/testable-projects-fcc/v1/bundle.js"></script>
    </body>
</html>